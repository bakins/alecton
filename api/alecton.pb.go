// Code generated by protoc-gen-go. DO NOT EDIT.
// source: alecton.proto

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	alecton.proto

It has these top-level messages:
	Cluster
	Image
	Target
	Application
	GetImageRequest
	ListImagesRequest
	ListImagesResponse
	ListApplicationsRequest
	ListApplicationsResponse
	GetApplicationRequest
	DeployRequest
	DeployResponse
	RollbackRequest
	RollbackResponse
	ListReleasesRequest
	ListReleasesResponse
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import hapi_release5 "k8s.io/helm/pkg/proto/hapi/release"
import _ "github.com/mwitkow/go-proto-validators"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Cluster represents a single Kubernetes cluster.
type Cluster struct {
	// Name is the user-freindly name. Deploy targets reference this.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Context is the context as defined in a kubeconfig.
	Context string `protobuf:"bytes,2,opt,name=context" json:"context,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Cluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

// Image is a single container image.
// Images are immutable.
type Image struct {
	// Name is the user-freindly name. Multiple images with the same
	// name are allowed as these would vary on version. Images with
	// same name should reference the same application code.
	// Applications reference this name.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Version is the verion of this image. This is usually the tag.
	Version string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	// Image is the full registry reference to the image.
	Image string `protobuf:"bytes,3,opt,name=image" json:"image,omitempty"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Image) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Image) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Image) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

// Target is a deployment target.
type Target struct {
	// Name of the target. As targets are application specific, this
	// only needs to be unique in the application.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Cluster is the target cluster. This must match a defined cluster.
	Cluster string `protobuf:"bytes,2,opt,name=cluster" json:"cluster,omitempty"`
	// Namespace within the cluster.
	Namespace string `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
	// Values are the values to be merged for this target.
	Values map[string]string `protobuf:"bytes,4,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Target) Reset()                    { *m = Target{} }
func (m *Target) String() string            { return proto.CompactTextString(m) }
func (*Target) ProtoMessage()               {}
func (*Target) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Target) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Target) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *Target) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Target) GetValues() map[string]string {
	if m != nil {
		return m.Values
	}
	return nil
}

// Application is a "wrapper" for a Chart, deployment targets,
// and values.
type Application struct {
	// Name must be unique.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Chart is the chart to use when deploying this application.
	Chart string `protobuf:"bytes,2,opt,name=chart" json:"chart,omitempty"`
	// Image is the image for this application.
	// On deployment, we set .Values.Image equal to the referenced image.
	// This makes the normal use case of single image apps more convenient.
	// For multi-image charts, the other images should have sensible defaults
	// and use a different .Values field if needed.
	Image string `protobuf:"bytes,3,opt,name=image" json:"image,omitempty"`
	// Deployment targets for this application.
	Targets []*Target `protobuf:"bytes,4,rep,name=targets" json:"targets,omitempty"`
}

func (m *Application) Reset()                    { *m = Application{} }
func (m *Application) String() string            { return proto.CompactTextString(m) }
func (*Application) ProtoMessage()               {}
func (*Application) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Application) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Application) GetChart() string {
	if m != nil {
		return m.Chart
	}
	return ""
}

func (m *Application) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Application) GetTargets() []*Target {
	if m != nil {
		return m.Targets
	}
	return nil
}

type GetImageRequest struct {
	Name    string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Version string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (m *GetImageRequest) Reset()                    { *m = GetImageRequest{} }
func (m *GetImageRequest) String() string            { return proto.CompactTextString(m) }
func (*GetImageRequest) ProtoMessage()               {}
func (*GetImageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GetImageRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetImageRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// ListImages and optionally filter.
type ListImagesRequest struct {
	Name    string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Version string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (m *ListImagesRequest) Reset()                    { *m = ListImagesRequest{} }
func (m *ListImagesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListImagesRequest) ProtoMessage()               {}
func (*ListImagesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ListImagesRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListImagesRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type ListImagesResponse struct {
	Images []*Image `protobuf:"bytes,1,rep,name=images" json:"images,omitempty"`
}

func (m *ListImagesResponse) Reset()                    { *m = ListImagesResponse{} }
func (m *ListImagesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListImagesResponse) ProtoMessage()               {}
func (*ListImagesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ListImagesResponse) GetImages() []*Image {
	if m != nil {
		return m.Images
	}
	return nil
}

// ListApplications and optionally filter.
type ListApplicationsRequest struct {
	Chart string `protobuf:"bytes,1,opt,name=chart" json:"chart,omitempty"`
	Image string `protobuf:"bytes,2,opt,name=image" json:"image,omitempty"`
}

func (m *ListApplicationsRequest) Reset()                    { *m = ListApplicationsRequest{} }
func (m *ListApplicationsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListApplicationsRequest) ProtoMessage()               {}
func (*ListApplicationsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ListApplicationsRequest) GetChart() string {
	if m != nil {
		return m.Chart
	}
	return ""
}

func (m *ListApplicationsRequest) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

type ListApplicationsResponse struct {
	Applications []*Application `protobuf:"bytes,1,rep,name=applications" json:"applications,omitempty"`
}

func (m *ListApplicationsResponse) Reset()                    { *m = ListApplicationsResponse{} }
func (m *ListApplicationsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListApplicationsResponse) ProtoMessage()               {}
func (*ListApplicationsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ListApplicationsResponse) GetApplications() []*Application {
	if m != nil {
		return m.Applications
	}
	return nil
}

type GetApplicationRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *GetApplicationRequest) Reset()                    { *m = GetApplicationRequest{} }
func (m *GetApplicationRequest) String() string            { return proto.CompactTextString(m) }
func (*GetApplicationRequest) ProtoMessage()               {}
func (*GetApplicationRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *GetApplicationRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Deploy an application to a cluster.
type DeployRequest struct {
	Application string `protobuf:"bytes,1,opt,name=application" json:"application,omitempty"`
	Target      string `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	// image version
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}

func (m *DeployRequest) Reset()                    { *m = DeployRequest{} }
func (m *DeployRequest) String() string            { return proto.CompactTextString(m) }
func (*DeployRequest) ProtoMessage()               {}
func (*DeployRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DeployRequest) GetApplication() string {
	if m != nil {
		return m.Application
	}
	return ""
}

func (m *DeployRequest) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *DeployRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type DeployResponse struct {
	// helm release
	Release *hapi_release5.Release `protobuf:"bytes,1,opt,name=release" json:"release,omitempty"`
}

func (m *DeployResponse) Reset()                    { *m = DeployResponse{} }
func (m *DeployResponse) String() string            { return proto.CompactTextString(m) }
func (*DeployResponse) ProtoMessage()               {}
func (*DeployResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *DeployResponse) GetRelease() *hapi_release5.Release {
	if m != nil {
		return m.Release
	}
	return nil
}

// Rollback to a previous release.
type RollbackRequest struct {
	Application string `protobuf:"bytes,1,opt,name=application" json:"application,omitempty"`
	Target      string `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	Version     int32  `protobuf:"varint,4,opt,name=version" json:"version,omitempty"`
}

func (m *RollbackRequest) Reset()                    { *m = RollbackRequest{} }
func (m *RollbackRequest) String() string            { return proto.CompactTextString(m) }
func (*RollbackRequest) ProtoMessage()               {}
func (*RollbackRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *RollbackRequest) GetApplication() string {
	if m != nil {
		return m.Application
	}
	return ""
}

func (m *RollbackRequest) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *RollbackRequest) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type RollbackResponse struct {
	Release *hapi_release5.Release `protobuf:"bytes,1,opt,name=release" json:"release,omitempty"`
}

func (m *RollbackResponse) Reset()                    { *m = RollbackResponse{} }
func (m *RollbackResponse) String() string            { return proto.CompactTextString(m) }
func (*RollbackResponse) ProtoMessage()               {}
func (*RollbackResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *RollbackResponse) GetRelease() *hapi_release5.Release {
	if m != nil {
		return m.Release
	}
	return nil
}

// list releases for an application/target
type ListReleasesRequest struct {
	Application string `protobuf:"bytes,1,opt,name=application" json:"application,omitempty"`
	Target      string `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
}

func (m *ListReleasesRequest) Reset()                    { *m = ListReleasesRequest{} }
func (m *ListReleasesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListReleasesRequest) ProtoMessage()               {}
func (*ListReleasesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ListReleasesRequest) GetApplication() string {
	if m != nil {
		return m.Application
	}
	return ""
}

func (m *ListReleasesRequest) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

type ListReleasesResponse struct {
	Releases []*hapi_release5.Release `protobuf:"bytes,1,rep,name=releases" json:"releases,omitempty"`
}

func (m *ListReleasesResponse) Reset()                    { *m = ListReleasesResponse{} }
func (m *ListReleasesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListReleasesResponse) ProtoMessage()               {}
func (*ListReleasesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ListReleasesResponse) GetReleases() []*hapi_release5.Release {
	if m != nil {
		return m.Releases
	}
	return nil
}

func init() {
	proto.RegisterType((*Cluster)(nil), "alecton.api.Cluster")
	proto.RegisterType((*Image)(nil), "alecton.api.Image")
	proto.RegisterType((*Target)(nil), "alecton.api.Target")
	proto.RegisterType((*Application)(nil), "alecton.api.Application")
	proto.RegisterType((*GetImageRequest)(nil), "alecton.api.GetImageRequest")
	proto.RegisterType((*ListImagesRequest)(nil), "alecton.api.ListImagesRequest")
	proto.RegisterType((*ListImagesResponse)(nil), "alecton.api.ListImagesResponse")
	proto.RegisterType((*ListApplicationsRequest)(nil), "alecton.api.ListApplicationsRequest")
	proto.RegisterType((*ListApplicationsResponse)(nil), "alecton.api.ListApplicationsResponse")
	proto.RegisterType((*GetApplicationRequest)(nil), "alecton.api.GetApplicationRequest")
	proto.RegisterType((*DeployRequest)(nil), "alecton.api.DeployRequest")
	proto.RegisterType((*DeployResponse)(nil), "alecton.api.DeployResponse")
	proto.RegisterType((*RollbackRequest)(nil), "alecton.api.RollbackRequest")
	proto.RegisterType((*RollbackResponse)(nil), "alecton.api.RollbackResponse")
	proto.RegisterType((*ListReleasesRequest)(nil), "alecton.api.ListReleasesRequest")
	proto.RegisterType((*ListReleasesResponse)(nil), "alecton.api.ListReleasesResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DeployService service

type DeployServiceClient interface {
	// CreateImage creates an image. It is not possible to overwrite an image.
	CreateImage(ctx context.Context, in *Image, opts ...grpc.CallOption) (*Image, error)
	ListImages(ctx context.Context, in *ListImagesRequest, opts ...grpc.CallOption) (*ListImagesResponse, error)
	GetImage(ctx context.Context, in *GetImageRequest, opts ...grpc.CallOption) (*Image, error)
	CreateApplication(ctx context.Context, in *Application, opts ...grpc.CallOption) (*Application, error)
	// must pass in complete application. there is no merge performed.
	UpdateApplication(ctx context.Context, in *Application, opts ...grpc.CallOption) (*Application, error)
	ListApplications(ctx context.Context, in *ListApplicationsRequest, opts ...grpc.CallOption) (*ListApplicationsResponse, error)
	GetApplication(ctx context.Context, in *GetApplicationRequest, opts ...grpc.CallOption) (*Application, error)
	// deploy will get the image referenced and perform the equivalent of:
	// helm upgrade --install --kube-context=[cluster-context] \
	//     --namespace=[target-namespace] \
	//     --reset-values \
	//     --set=[target-values] \
	//     [application-name]-[target-name] [application-chart]
	DeployApplication(ctx context.Context, in *DeployRequest, opts ...grpc.CallOption) (*DeployResponse, error)
	// performs the equivalent of:
	// helm rollback --kube-context=[cluster-context] \
	//     [application-name]-[target-name] [REVISION]
	RollbackApplication(ctx context.Context, in *RollbackRequest, opts ...grpc.CallOption) (*RollbackResponse, error)
	// performs the equivalent of:
	// helm history --kube-context=[cluster-context] \
	//    [application-name]-[target-name]
	ListReleases(ctx context.Context, in *ListReleasesRequest, opts ...grpc.CallOption) (*ListReleasesResponse, error)
}

type deployServiceClient struct {
	cc *grpc.ClientConn
}

func NewDeployServiceClient(cc *grpc.ClientConn) DeployServiceClient {
	return &deployServiceClient{cc}
}

func (c *deployServiceClient) CreateImage(ctx context.Context, in *Image, opts ...grpc.CallOption) (*Image, error) {
	out := new(Image)
	err := grpc.Invoke(ctx, "/alecton.api.DeployService/CreateImage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployServiceClient) ListImages(ctx context.Context, in *ListImagesRequest, opts ...grpc.CallOption) (*ListImagesResponse, error) {
	out := new(ListImagesResponse)
	err := grpc.Invoke(ctx, "/alecton.api.DeployService/ListImages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployServiceClient) GetImage(ctx context.Context, in *GetImageRequest, opts ...grpc.CallOption) (*Image, error) {
	out := new(Image)
	err := grpc.Invoke(ctx, "/alecton.api.DeployService/GetImage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployServiceClient) CreateApplication(ctx context.Context, in *Application, opts ...grpc.CallOption) (*Application, error) {
	out := new(Application)
	err := grpc.Invoke(ctx, "/alecton.api.DeployService/CreateApplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployServiceClient) UpdateApplication(ctx context.Context, in *Application, opts ...grpc.CallOption) (*Application, error) {
	out := new(Application)
	err := grpc.Invoke(ctx, "/alecton.api.DeployService/UpdateApplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployServiceClient) ListApplications(ctx context.Context, in *ListApplicationsRequest, opts ...grpc.CallOption) (*ListApplicationsResponse, error) {
	out := new(ListApplicationsResponse)
	err := grpc.Invoke(ctx, "/alecton.api.DeployService/ListApplications", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployServiceClient) GetApplication(ctx context.Context, in *GetApplicationRequest, opts ...grpc.CallOption) (*Application, error) {
	out := new(Application)
	err := grpc.Invoke(ctx, "/alecton.api.DeployService/GetApplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployServiceClient) DeployApplication(ctx context.Context, in *DeployRequest, opts ...grpc.CallOption) (*DeployResponse, error) {
	out := new(DeployResponse)
	err := grpc.Invoke(ctx, "/alecton.api.DeployService/DeployApplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployServiceClient) RollbackApplication(ctx context.Context, in *RollbackRequest, opts ...grpc.CallOption) (*RollbackResponse, error) {
	out := new(RollbackResponse)
	err := grpc.Invoke(ctx, "/alecton.api.DeployService/RollbackApplication", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deployServiceClient) ListReleases(ctx context.Context, in *ListReleasesRequest, opts ...grpc.CallOption) (*ListReleasesResponse, error) {
	out := new(ListReleasesResponse)
	err := grpc.Invoke(ctx, "/alecton.api.DeployService/ListReleases", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DeployService service

type DeployServiceServer interface {
	// CreateImage creates an image. It is not possible to overwrite an image.
	CreateImage(context.Context, *Image) (*Image, error)
	ListImages(context.Context, *ListImagesRequest) (*ListImagesResponse, error)
	GetImage(context.Context, *GetImageRequest) (*Image, error)
	CreateApplication(context.Context, *Application) (*Application, error)
	// must pass in complete application. there is no merge performed.
	UpdateApplication(context.Context, *Application) (*Application, error)
	ListApplications(context.Context, *ListApplicationsRequest) (*ListApplicationsResponse, error)
	GetApplication(context.Context, *GetApplicationRequest) (*Application, error)
	// deploy will get the image referenced and perform the equivalent of:
	// helm upgrade --install --kube-context=[cluster-context] \
	//     --namespace=[target-namespace] \
	//     --reset-values \
	//     --set=[target-values] \
	//     [application-name]-[target-name] [application-chart]
	DeployApplication(context.Context, *DeployRequest) (*DeployResponse, error)
	// performs the equivalent of:
	// helm rollback --kube-context=[cluster-context] \
	//     [application-name]-[target-name] [REVISION]
	RollbackApplication(context.Context, *RollbackRequest) (*RollbackResponse, error)
	// performs the equivalent of:
	// helm history --kube-context=[cluster-context] \
	//    [application-name]-[target-name]
	ListReleases(context.Context, *ListReleasesRequest) (*ListReleasesResponse, error)
}

func RegisterDeployServiceServer(s *grpc.Server, srv DeployServiceServer) {
	s.RegisterService(&_DeployService_serviceDesc, srv)
}

func _DeployService_CreateImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Image)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployServiceServer).CreateImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alecton.api.DeployService/CreateImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployServiceServer).CreateImage(ctx, req.(*Image))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployService_ListImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployServiceServer).ListImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alecton.api.DeployService/ListImages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployServiceServer).ListImages(ctx, req.(*ListImagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployService_GetImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployServiceServer).GetImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alecton.api.DeployService/GetImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployServiceServer).GetImage(ctx, req.(*GetImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployService_CreateApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Application)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployServiceServer).CreateApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alecton.api.DeployService/CreateApplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployServiceServer).CreateApplication(ctx, req.(*Application))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployService_UpdateApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Application)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployServiceServer).UpdateApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alecton.api.DeployService/UpdateApplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployServiceServer).UpdateApplication(ctx, req.(*Application))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployService_ListApplications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListApplicationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployServiceServer).ListApplications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alecton.api.DeployService/ListApplications",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployServiceServer).ListApplications(ctx, req.(*ListApplicationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployService_GetApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetApplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployServiceServer).GetApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alecton.api.DeployService/GetApplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployServiceServer).GetApplication(ctx, req.(*GetApplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployService_DeployApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployServiceServer).DeployApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alecton.api.DeployService/DeployApplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployServiceServer).DeployApplication(ctx, req.(*DeployRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployService_RollbackApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployServiceServer).RollbackApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alecton.api.DeployService/RollbackApplication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployServiceServer).RollbackApplication(ctx, req.(*RollbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeployService_ListReleases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReleasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeployServiceServer).ListReleases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/alecton.api.DeployService/ListReleases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeployServiceServer).ListReleases(ctx, req.(*ListReleasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DeployService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "alecton.api.DeployService",
	HandlerType: (*DeployServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateImage",
			Handler:    _DeployService_CreateImage_Handler,
		},
		{
			MethodName: "ListImages",
			Handler:    _DeployService_ListImages_Handler,
		},
		{
			MethodName: "GetImage",
			Handler:    _DeployService_GetImage_Handler,
		},
		{
			MethodName: "CreateApplication",
			Handler:    _DeployService_CreateApplication_Handler,
		},
		{
			MethodName: "UpdateApplication",
			Handler:    _DeployService_UpdateApplication_Handler,
		},
		{
			MethodName: "ListApplications",
			Handler:    _DeployService_ListApplications_Handler,
		},
		{
			MethodName: "GetApplication",
			Handler:    _DeployService_GetApplication_Handler,
		},
		{
			MethodName: "DeployApplication",
			Handler:    _DeployService_DeployApplication_Handler,
		},
		{
			MethodName: "RollbackApplication",
			Handler:    _DeployService_RollbackApplication_Handler,
		},
		{
			MethodName: "ListReleases",
			Handler:    _DeployService_ListReleases_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "alecton.proto",
}

func init() { proto.RegisterFile("alecton.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 891 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x6d, 0x6b, 0xdb, 0x56,
	0x14, 0x46, 0x71, 0x6c, 0xa7, 0xc7, 0x69, 0x93, 0x9c, 0x24, 0x54, 0x55, 0xdc, 0xc4, 0xbb, 0x4d,
	0x21, 0x74, 0xc4, 0xa2, 0x29, 0xac, 0x5b, 0xd9, 0x87, 0xb5, 0x59, 0x29, 0x85, 0xc2, 0x40, 0x7b,
	0x61, 0xec, 0xcb, 0xb8, 0x91, 0x2f, 0x8e, 0x88, 0xa2, 0xab, 0x49, 0x37, 0x6e, 0x83, 0x31, 0x8c,
	0xfd, 0x85, 0xed, 0x57, 0xed, 0xeb, 0x7e, 0xc0, 0xc6, 0xd8, 0x0f, 0x19, 0xba, 0x2f, 0xf6, 0x95,
	0x64, 0xbb, 0x63, 0xcb, 0x3e, 0x49, 0x3a, 0xe7, 0xdc, 0xf3, 0x9c, 0xe7, 0x9c, 0x73, 0x1f, 0x1b,
	0x6e, 0xd3, 0x98, 0x85, 0x82, 0x27, 0xfd, 0x34, 0xe3, 0x82, 0x63, 0xc7, 0x7c, 0xd2, 0x34, 0xf2,
	0xba, 0x43, 0xce, 0x87, 0x31, 0xf3, 0x69, 0x1a, 0xf9, 0x34, 0x49, 0xb8, 0xa0, 0x22, 0xe2, 0x49,
	0xae, 0x42, 0x3d, 0xef, 0xbc, 0xb0, 0x67, 0x2c, 0x66, 0x34, 0x67, 0xe6, 0xa9, 0x7d, 0x1f, 0x0d,
	0x23, 0x71, 0x7e, 0x75, 0xd6, 0x0f, 0xf9, 0xa5, 0x7f, 0xf9, 0x36, 0x12, 0x17, 0xfc, 0xad, 0x3f,
	0xe4, 0xc7, 0xd2, 0x79, 0x3c, 0xa2, 0x71, 0x34, 0xa0, 0x82, 0x67, 0xb9, 0x3f, 0x7d, 0x55, 0xe7,
	0xc8, 0x53, 0x68, 0x9f, 0xc6, 0x57, 0xb9, 0x60, 0x19, 0x22, 0xac, 0x26, 0xf4, 0x92, 0xb9, 0x4e,
	0xcf, 0x39, 0xba, 0x15, 0xc8, 0x77, 0x74, 0xa1, 0x1d, 0xf2, 0x44, 0xb0, 0x77, 0xc2, 0x5d, 0x91,
	0x66, 0xf3, 0x49, 0x42, 0x68, 0xbe, 0xbe, 0xa4, 0x43, 0x86, 0x9e, 0x7d, 0xec, 0x45, 0xeb, 0xcf,
	0xdf, 0x0f, 0x56, 0x7a, 0x8e, 0x3e, 0xde, 0x83, 0xf6, 0x88, 0x65, 0x79, 0xc4, 0x13, 0x75, 0x7c,
	0xea, 0x36, 0x66, 0xec, 0x42, 0x33, 0x2a, 0xd2, 0xb8, 0x8d, 0x92, 0x5f, 0x19, 0xc9, 0x1f, 0x0e,
	0xb4, 0xbe, 0xa2, 0xd9, 0x90, 0x89, 0xf7, 0xc1, 0x84, 0x8a, 0x44, 0x15, 0x46, 0x9b, 0xf1, 0x10,
	0x6e, 0x15, 0x91, 0x79, 0x4a, 0xc3, 0x2a, 0xd4, 0xcc, 0x81, 0x4f, 0xa1, 0x35, 0xa2, 0xf1, 0x15,
	0xcb, 0xdd, 0xd5, 0x5e, 0xe3, 0xa8, 0x73, 0x72, 0xd0, 0xb7, 0x86, 0xd3, 0x57, 0x85, 0xf4, 0xbf,
	0x91, 0x11, 0x2f, 0x13, 0x91, 0x5d, 0x07, 0x3a, 0xdc, 0xfb, 0x04, 0x3a, 0x96, 0x19, 0x37, 0xa1,
	0x71, 0xc1, 0xae, 0x75, 0x23, 0x8b, 0x57, 0xdc, 0x81, 0xa6, 0x0c, 0xd5, 0x5d, 0x54, 0x1f, 0xcf,
	0x56, 0x3e, 0x76, 0xc8, 0x2f, 0x0e, 0x74, 0x9e, 0xa7, 0x69, 0x1c, 0x85, 0x72, 0xd6, 0x4b, 0x79,
	0x76, 0xa1, 0x19, 0x9e, 0xd3, 0x4c, 0x54, 0x58, 0x2a, 0xe3, 0xf2, 0x56, 0xe2, 0x31, 0xb4, 0x85,
	0x24, 0x60, 0xc8, 0x6d, 0xcf, 0x21, 0x17, 0x98, 0x18, 0xf2, 0x05, 0x6c, 0xbc, 0x62, 0x42, 0x4e,
	0x38, 0x60, 0x3f, 0x5c, 0xb1, 0x5c, 0xfc, 0xb7, 0x41, 0x93, 0xe7, 0xb0, 0xf5, 0x26, 0xca, 0x55,
	0xc6, 0xdc, 0xa4, 0x5c, 0xb0, 0x72, 0xa5, 0x54, 0xb3, 0x14, 0x9f, 0x01, 0xda, 0x29, 0xf2, 0x94,
	0x27, 0x39, 0xc3, 0x47, 0xd0, 0x92, 0x0c, 0x73, 0xd7, 0x91, 0xbc, 0xb0, 0xc4, 0x4b, 0x31, 0xd0,
	0x11, 0xe4, 0x25, 0xdc, 0x2d, 0x32, 0x58, 0xfd, 0x9e, 0x96, 0xb2, 0x63, 0x7a, 0xab, 0x6a, 0xd1,
	0x3d, 0xdd, 0x31, 0x3d, 0xd5, 0x73, 0x53, 0x6b, 0xf9, 0x2d, 0xb8, 0xf5, 0x34, 0xba, 0x9c, 0x4f,
	0x61, 0x9d, 0x5a, 0x76, 0x5d, 0x94, 0x5b, 0x2a, 0xca, 0x3a, 0x18, 0x94, 0xa2, 0xc9, 0x13, 0xd8,
	0x7d, 0xc5, 0xec, 0xc4, 0xff, 0xa0, 0xf9, 0x64, 0x0c, 0xb7, 0x3f, 0x67, 0x69, 0xcc, 0xaf, 0x4d,
	0xf0, 0x11, 0x74, 0xac, 0xac, 0x95, 0x33, 0xb6, 0x0b, 0xf7, 0xa1, 0xa5, 0x26, 0x5e, 0x19, 0x9b,
	0xb6, 0xda, 0x73, 0x6d, 0x2c, 0x9a, 0xeb, 0x1d, 0x03, 0xae, 0x3b, 0xe0, 0x43, 0x5b, 0x6b, 0x93,
	0x44, 0xee, 0x9c, 0xec, 0xf6, 0x0b, 0xe1, 0xea, 0x1b, 0xc1, 0x0a, 0xd4, 0x33, 0x30, 0x51, 0x64,
	0x02, 0x1b, 0x01, 0x8f, 0xe3, 0x33, 0x1a, 0x5e, 0xfc, 0xaf, 0x0c, 0x56, 0x7b, 0xce, 0x51, 0xb3,
	0xce, 0xe0, 0x14, 0x36, 0x67, 0xf0, 0xff, 0x96, 0xc3, 0xf7, 0xb0, 0x5d, 0xac, 0x84, 0xb6, 0xe7,
	0x37, 0xce, 0x83, 0xbc, 0x86, 0x9d, 0x32, 0x80, 0xae, 0xf4, 0x31, 0xac, 0xe9, 0x1a, 0xcc, 0xae,
	0x2d, 0x28, 0x75, 0x1a, 0x76, 0xf2, 0xeb, 0x9a, 0x59, 0x98, 0x2f, 0x59, 0x36, 0x8a, 0x42, 0x86,
	0x6f, 0xa0, 0x73, 0x9a, 0x31, 0x2a, 0x98, 0x92, 0xf4, 0x39, 0x57, 0xc8, 0x9b, 0x63, 0x23, 0xbb,
	0x3f, 0xfd, 0xf6, 0xd7, 0xcf, 0x2b, 0x1b, 0x04, 0xfc, 0xd1, 0x63, 0x5f, 0x5d, 0xb1, 0x67, 0xce,
	0x23, 0xa4, 0x00, 0xb3, 0x7b, 0x8a, 0xfb, 0xa5, 0x83, 0x35, 0x0d, 0xf0, 0x0e, 0x16, 0xfa, 0x15,
	0x43, 0x82, 0x12, 0x65, 0x1d, 0x2d, 0x14, 0xa4, 0xb0, 0x66, 0xe4, 0x09, 0xbb, 0xa5, 0x04, 0x15,
	0xd5, 0x9a, 0x5b, 0xf7, 0x03, 0x99, 0xf1, 0x3e, 0xee, 0xcd, 0x32, 0xfa, 0xe3, 0xe2, 0x2a, 0x4d,
	0xfc, 0xb1, 0xde, 0x8a, 0x09, 0x0e, 0x60, 0x4b, 0xf5, 0xc4, 0x56, 0xe7, 0x85, 0xf7, 0xd8, 0x5b,
	0xe8, 0x21, 0x7b, 0x12, 0x6d, 0x97, 0x6c, 0x16, 0x68, 0xf6, 0x6d, 0x2f, 0x7a, 0x35, 0x80, 0xad,
	0xaf, 0xd3, 0xc1, 0xcd, 0xa1, 0x78, 0x73, 0x51, 0xae, 0x61, 0xb3, 0x2a, 0x58, 0x78, 0x58, 0xeb,
	0xfb, 0x1c, 0x59, 0xf4, 0x1e, 0xbe, 0x27, 0x4a, 0xcf, 0xc8, 0x95, 0xe8, 0x88, 0x35, 0x74, 0xe4,
	0x70, 0xa7, 0xac, 0x68, 0x48, 0xaa, 0xf3, 0xaa, 0xcb, 0xdd, 0x12, 0x9e, 0x07, 0x12, 0xe9, 0x1e,
	0xde, 0xad, 0x22, 0xe9, 0x09, 0x62, 0x0a, 0x5b, 0x6a, 0xb9, 0x4b, 0xbf, 0xaa, 0xa5, 0x7c, 0x25,
	0xb5, 0xf4, 0xf6, 0xe6, 0xfa, 0x34, 0x31, 0x22, 0xe1, 0xba, 0xa4, 0x0e, 0x37, 0x90, 0x81, 0x45,
	0x77, 0xdf, 0xc1, 0xb6, 0x11, 0x10, 0x1b, 0xb3, 0xbc, 0x97, 0x15, 0x85, 0xf3, 0xee, 0x2f, 0xf0,
	0x6a, 0xdc, 0x43, 0x89, 0xbb, 0x4f, 0xee, 0xd5, 0x70, 0x33, 0x1d, 0x5a, 0x20, 0xff, 0xe8, 0xc0,
	0xba, 0xad, 0x0a, 0xd8, 0xab, 0x8d, 0xab, 0xa2, 0x48, 0xde, 0x07, 0x4b, 0x22, 0x34, 0xf6, 0x87,
	0x12, 0xfb, 0x21, 0x3e, 0x28, 0xb0, 0x8d, 0x6a, 0xf8, 0x63, 0xab, 0x8a, 0x89, 0x3f, 0x56, 0xb2,
	0x34, 0x79, 0xd1, 0xfc, 0xae, 0x41, 0xd3, 0xe8, 0xac, 0x25, 0xff, 0x4e, 0x3e, 0xf9, 0x3b, 0x00,
	0x00, 0xff, 0xff, 0x78, 0x91, 0xfa, 0x14, 0xde, 0x0a, 0x00, 0x00,
}
